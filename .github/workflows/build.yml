name: OCI Ubuntu ARM Instance Auto-Manager

# 触发条件
on:
  # 定时触发：每小时运行一次（整点执行）
  schedule:
    - cron: '0 */4 * * *'
  # 手动触发：允许通过GitHub界面手动运行
  workflow_dispatch:
    inputs:
      manual_trigger_reason:
        description: '手动触发原因'
        required: false
        default: '测试或紧急操作'

jobs:
  manage-oci-instances:
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 30

    steps:
      # ==========================================================================
      # 步骤1：检出代码仓库
      # ==========================================================================
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # ==========================================================================
      # 步骤2：配置OCI认证信息
      # 所需Secrets：
      # - OCI_USER: Oracle Cloud用户OCID
      # - OCI_TENANCY: Oracle Cloud租户OCID
      # - OCI_FINGERPRINT: API密钥指纹
      # - OCI_REGION: 区域标识符（如：us-ashburn-1）
      # - OCI_PRIVATE_KEY: API私钥内容（PEM格式）
      # ==========================================================================
      - name: Configure OCI authentication
        run: |
          echo "=== 配置OCI认证信息 ==="
          
          # 创建OCI配置目录
          mkdir -p ~/.oci
          
          # 生成OCI配置文件
          cat > ~/.oci/config << 'CONFIG_EOF'
          [DEFAULT]
          user=${{ secrets.OCI_USER }}
          tenancy=${{ secrets.OCI_TENANCY }}
          fingerprint=${{ secrets.OCI_FINGERPRINT }}
          region=${{ secrets.OCI_REGION }}
          key_file=~/.oci/oci_api_key.pem
          CONFIG_EOF
          
          # 保存API私钥（更健壮的写法）
          if [ -z "${{ secrets.OCI_PRIVATE_KEY }}" ]; then
            echo "❌ OCI_PRIVATE_KEY secret is empty or not available in this workflow run."
            echo "   - 参数不存在"
            echo "   - 如果这是来自 fork 的 PR 或非受信任触发，GitHub 可能不会注入 Secrets。"
            exit 1
          fi

          echo "${{ secrets.OCI_PRIVATE_KEY }}" > ~/.oci/oci_api_key.pem

          # 设置文件权限（安全要求）
          chmod 600 ~/.oci/config
          chmod 600 ~/.oci/oci_api_key.pem

          # 输出文件大小与末行以便验证（不会打印私钥主体）
          echo "oci_api_key.pem size: $(wc -c < ~/.oci/oci_api_key.pem) bytes"
          echo "oci_api_key.pem last line: '$(tail -n 1 ~/.oci/oci_api_key.pem)'"
          
          echo "✅ OCI认证配置完成"

      # ==========================================================================
      # 步骤3：安装OCI CLI工具
      # ==========================================================================
      - name: Install OCI CLI
        run: |
          echo "=== 安装OCI CLI工具 ==="
          
          # 下载并安装OCI CLI
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh | bash -s -- --accept-all-defaults
          
          # 配置环境变量
          echo 'export PATH=$HOME/bin:$PATH' >> ~/.bashrc
          source ~/.bashrc
          # 将 $HOME/bin 写入 GITHUB_PATH，确保后续步骤可以直接使用 oci
          echo "$HOME/bin" >> $GITHUB_PATH
          # 立即把 $HOME/bin 加入当前 PATH，使得本步骤可以立刻使用 oci
          export PATH="$HOME/bin:$PATH"
          
          # 验证安装
          oci --version
          echo "✅ OCI CLI安装完成"

      # ======================================================================
      # 步骤3.1：预检 OCI 配置（验证身份和 Compartment）
      # ======================================================================
      - name: Pre-check OCI configuration
        run: |
          echo "=== 预检 OCI 配置 ==="
          set -e
          echo "检查代码已注释，不生效，避免暴露信息"
          # # 打印当前 config（不要把私钥上传到日志）
          # echo "=== ~/.oci/config (first 40 lines) ==="
          # sed -n '1,40p' ~/.oci/config || true

          # # 验证用户（应返回 user data）
          # echo "=== oci iam user get ==="
          # oci iam user get --user-id "${{ secrets.OCI_USER }}" --raw-output || echo "user get failed (see above)"

          # # 检查 compartment 是否存在并返回详情（这是目前失败的调用）
          # echo "=== oci iam compartment get ==="
          # oci iam compartment get --compartment-id "${{secrets.OCI_TENANCY}}" --raw-output || echo "compartment get failed (可能是 OCID 错/无权限)"

          # # 在 tenancy 下列出所有 compartments（用来在列表中确认你使用的 OCID）
          # echo "=== list compartments under tenancy ==="
          # oci iam compartment list --compartment-id "${{secrets.OCI_TENANCY}}" --all --output table || echo "compartment list failed (权限?)"

          # # 列出当前用户所属的组（用于确认用户属于哪个组）
          # echo "=== groups for user ==="
          # oci iam user list-groups --user-id "${{ secrets.OCI_USER }}" --raw-output || echo "list-groups failed (权限?)"

          # # 列出 tenancy 下的 policy（帮助查看是否存在授予所属组访问该 compartment 的策略）
          # echo "=== policy list in tenancy ==="
          # oci iam policy list --compartment-id "${{secrets.OCI_TENANCY}}" --all --output table || echo "policy list failed (权限?)"

          # # 作为最终测试，尝试对目标 compartment 列出 compute 实例（这一步如果权限缺会报 NotAuthorizedOrNotFound）
          # echo "=== compute instance list (test) ==="
          # oci compute instance list --compartment-id "${{secrets.OCI_TENANCY}}" --all --output table || echo "compute list failed"

          # echo "✅ 预检通过：OCI 配置看起来正常"

      # ==========================================================================
      # 步骤4：检查实例状态
      # 逻辑：如果存在任何状态的实例，终止工作流
      # ==========================================================================
      - name: Check instance existence
        run: |
          echo "=== 检查是否存在任何实例（TERMINATED 可忽略） ==="

          # 容错执行 list 调用以便在失败时输出 debug 帮助排查
          set +e
          instances_json=$(oci compute instance list \
            --compartment-id "${{secrets.OCI_TENANCY}}" \
            --query 'data[*].{id:id, name:"display-name", shape:shape, state:"lifecycle-state"}' \
            --raw-output 2>/dev/null)
          rc=$?
          set -e

          if [ $rc -ne 0 ]; then
            echo "OCI CLI list failed; printing debug output to help troubleshooting"
            oci --debug compute instance list \
              --compartment-id "${{secrets.OCI_TENANCY}}" \
              --query 'data[*].{id:id, name:"display-name", shape:shape, state:"lifecycle-state"}' \
              --raw-output || true
            echo "检查建议：确认仓库 Secrets 中的 OCI_TENANCY/OCI_USER/OCI_FINGERPRINT/OCI_REGION/OCI_PRIVATE_KEY 是否为正确值，且所用用户有 list instances 的权限。"
            exit 1
          fi

          # 处理可能的 null 返回，确保为数组
          instances_json=${instances_json:-[]}

          # 过滤掉 lifecycle-state 为 TERMINATED 的实例，统计剩余（非 TERMINATED）数量
          non_terminated_json=$(echo "$instances_json" | jq '[.[] | select(.state != "TERMINATED")]')
          non_terminated_count=$(echo "$non_terminated_json" | jq 'length')
          total_count=$(echo "$instances_json" | jq 'length')

          echo "总共发现 $total_count 个实例；其中非 TERMINATED 的数量：$non_terminated_count"

          if [ "$non_terminated_count" -gt 0 ]; then
            echo "存在非 TERMINATED 的实例，列出并终止工作流："
            echo "$non_terminated_json" | jq -r '.[] | "- 名称：\(.name) | 类型：\(.shape) | 状态：\(.state) | ID：\(.id)"'
            echo "❌ 发现正在运行/非终止状态的实例，终止工作流"
            exit 1
          else
            if [ "$total_count" -gt 0 ]; then
              echo "发现的实例均为 TERMINATED（可继续创建新实例）："
              echo "$instances_json" | jq -r '.[] | "- 名称：\(.name) | 类型：\(.shape) | 状态：\(.state) | ID：\(.id)"'
            else
              echo "未发现任何实例，继续执行"
            fi
            echo "✅ 继续执行后续步骤"
          fi

      # ==========================================================================
      # 步骤5：创建新的Ubuntu ARM实例（4C24G）
      # 所需Secrets：
      # - SSH_PUBLIC_KEY: 用于SSH登录的公钥
      # ==========================================================================
      - name: Create new Ubuntu ARM instance (4C24G)
        run: |
          echo "=== 创建新的Ubuntu ARM实例 ==="
          echo "配置信息："
          echo "- 实例类型：VM.Standard.A1.Flex"
          echo "- CPU配置：4 OCPU"
          echo "- 内存配置：24 GB"
          echo "- 架构类型：ARM (Ampere A1)"
          echo "- 操作系统：Canonical Ubuntu 22.04 Minimal aarch64"
          echo "- 网络配置：分配公网IP"
          echo "- 符合Oracle Cloud始终免费条件"
          
          # 获取可用性域（使用 tenancy OCID）
          echo "正在获取可用性域..."
          ad=$(oci iam availability-domain list \
            --compartment-id ${{secrets.OCI_TENANCY}} \
            --query 'data[0]."name"' \
            --raw-output)
          echo "使用可用性域：$ad"
          
          # 获取Ubuntu 22.04 ARM镜像列表（先保存完整 JSON 以便调试）
          echo "正在列出镜像（OCI CLI 调用）..."
          image_id=$(oci compute image list \
              --compartment-id "${{secrets.OCI_TENANCY}}" \
              --operating-system "Canonical Ubuntu" \
              --operating-system-version "22.04" \
              --all \
              --query "data[0].id" \
              --raw-output)
          
          echo "使用镜像ID：$image_id"
          
          # 获取网络配置
          echo "正在获取网络配置..."
          vcn_id=$(oci network vcn list \
            --compartment-id ${{secrets.OCI_TENANCY}} \
            --query 'data[0]."id"' \
            --raw-output)
          subnet_id=$(oci network subnet list \
            --compartment-id ${{secrets.OCI_TENANCY}} \
            --vcn-id $vcn_id \
            --query 'data[0]."id"' \
            --raw-output)
          echo "网络配置ID：$subnet_id"
          
          # 生成唯一实例名称
          instance_name="ubuntu-arm-4c24g-$(date +%Y%m%d-%H%M%S)"
          echo "实例名称：$instance_name"
          
          # 启动实例（捕获可能的错误，不让步骤直接失败，以便后续判断并根据 message 决定是否发送邮件）
          echo "正在启动实例，请稍候..."
          if [ -z "${{secrets.SSH_PUBLIC_KEY}}" ]; then
            echo "❌ SSH_PUBLIC_KEY is empty. Please provide SSH public key as workflow input."
            exit 1
          fi

          # 允许命令失败并把 stderr 保存到文件，以便提取错误 message
          set +e
          # 先清理旧文件
          rm -f oci_err.json response.json || true

          instance_response=$(oci compute instance launch \
            --availability-domain "$ad" \
            --compartment-id "${{secrets.OCI_TENANCY}}" \
            --shape "VM.Standard.A1.Flex" \
            --shape-config '{"ocpus": 4, "memoryInGBs": 24}' \
            --display-name "$instance_name" \
            --image-id "$image_id" \
            --subnet-id "$subnet_id" \
            --ssh-authorized-keys-file <(echo "${{secrets.SSH_PUBLIC_KEY}}") \
            --assign-public-ip true \
            --connection-timeout 30 \
            --read-timeout 600 \
            --query 'data' \
            --raw-output 2>oci_err.json)
          rc=$?
          set -e

          echo "=== oci_err.json ==="
          if [ -s oci_err.json ]; then
            echo "----- begin oci_err.json -----"
            cat oci_err.json || true
            echo "----- end oci_err.json -----"
          else
            echo "oci_err.json is empty or not present"
          fi
               
          if [ $rc -ne 0 ]; then
            echo "OCI CLI returned non-zero exit code: $rc"

            # 尝试从 stderr 中提取 JSON 部分并解析 message 字段
            err_json=$(awk 'BEGIN{p=0} { if(p==1) print; else if(match($0,/\{/)){print substr($0, RSTART); p=1} }' oci_err.json || true)
            if [ -n "$err_json" ]; then
              msg=$(echo "$err_json" | jq -r '.message // empty' || true)
            else
              # 如果没有 JSON，尝试直接从 stderr 中抽取简单的 message 行
              msg=$(grep -oE '"message":\s*"[^"]+"' oci_err.json | sed -E 's/"message":\s*"(.*)"/\1/' | head -n1 || true)
            fi

            msg=${msg:-"(unknown oci error)"}

            # 写入 response.json 以供后续步骤读取，并导出到环境变量
            echo "{ \"message\": \"$msg\" }" > response.json
            echo "RESPONSE_MESSAGE=$msg" >> $GITHUB_ENV

            echo "Captured error message: $msg"
          else
            echo "实例启动命令返回成功，解析实例信息"
            instance_id=$(echo "$instance_response" | jq -r '.id' || true)
            lifecycle_state=$(echo "$instance_response" | jq -r '."lifecycle-state"' || true)
            private_ip=$(echo "$instance_response" | jq -r '.primary_vnic["private-ip"]' || true)

            echo "✅ 实例创建成功！"
            echo "- 实例ID：$instance_id"
            echo "- 当前状态：$lifecycle_state"
            echo "- 私有IP：$private_ip"

            # 同样写入 response.json，保持统一格式
            echo "{ \"message\": "$(printf '%s' "${lifecycle_state:-"SUCCEEDED"}" | jq -R .)" }" > response.json || true
            echo "RESPONSE_MESSAGE=${lifecycle_state:-SUCCEEDED}" >> $GITHUB_ENV || true

            # 等待实例完全启动
            echo "等待实例完全启动（最多等待5分钟）..."
            sleep 300
            
            # 获取公网IP
            echo "正在获取公网IP..."
            public_ip=$(oci compute instance list-vnics \
              --instance-id "$instance_id" \
              --query 'data[0]."public-ip"' \
              --raw-output)
            
            # 输出连接信息
            echo "📋 实例连接信息："
            echo "- 实例名称：$instance_name"
            echo "- 实例ID：$instance_id"
            echo "- 实例状态：$(oci compute instance get --instance-id $instance_id --query 'data["lifecycle-state"]' --raw-output)"
            echo "- 私有IP：$private_ip"
            echo "- 公网IP：$public_ip"
            echo "- SSH用户名：ubuntu"
            echo "- SSH连接命令：ssh ubuntu@$public_ip"
            echo "- 注意：首次连接可能需要等待几分钟"
          fi

      # ==========================================================================
      # 步骤6：决定是否发送邮件（仅当返回 message 与 repository 根目录的 message.json 不同时）
      # 逻辑说明：
      # - 优先使用环境变量 RESPONSE_MESSAGE（可由前面的步骤通过 "echo "::set-output name=response::${MSG}"" 或者写入 response.json 并设置到 env 中）
      # - 如果 RESPONSE_MESSAGE 为空，则尝试读取 workspace 根目录的 response.json 中的 message 字段
      # - 将其与仓库中的 message.json 的 message 数组进行比较；如果不包含则标记 should_send=true
      # 注意：GitHub Actions 在未来会移除 set-output 的旧语法，下面使用的是 step outputs 通过 echo "::set-output" 保持兼容性并同时导出到 GITHUB_OUTPUT
      - name: Decide whether to send email
        id: decide
        run: |
          echo "=== Decide whether to send email ==="
          set -e

          # 读取仓库内的 message.json 中的 message 数组（期望为 JSON 数组）
          if [ ! -f message.json ]; then
            echo "message.json not found in repository root"
            echo "should_send=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          repo_messages=$(jq -c '.message' message.json)
          echo "repo_messages=$repo_messages"

          # 优先从环境变量读取 RESPONSE_MESSAGE
          response_message="${{ env.RESPONSE_MESSAGE }}"

          # 如果环境变量未提供，再尝试读取 response.json（如果存在）
          if [ -z "$response_message" ] && [ -f response.json ]; then
            # 尝试从 response.json 中提取 message（允许为字符串或对象）
            response_message=$(jq -r '.message // empty' response.json || true)
          fi

          # 如果仍为空，尝试从步骤输出或临时文件中读取（保留弹性）
          if [ -z "$response_message" ]; then
            echo "No RESPONSE_MESSAGE or response.json message found; will not send email"
            echo "should_send=false" >> $GITHUB_OUTPUT
            echo "response_message=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "response_message=$response_message"

          # 规范化：去除首尾空白，避免比较时被多余空格或换行影响
          response_message=$(printf '%s' "$response_message" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          echo "normalized response_message=$response_message"

          # 判断 response_message 是否在 repo_messages 数组中
          # 使用 jq 来检查包含关系；如果 repo_messages 是数组，检查任何元素等于 response_message
          contains=$(echo "$repo_messages" | jq --arg rm "$response_message" 'index($rm) != null')

          # 逻辑：当 response_message 与 message.json 中任一项不相同时，才发送邮件（即 mismatch -> send）
          if [ "$contains" = "true" ]; then
            echo "response_message found in message.json; match -> skip sending email"
            echo "should_send=false" >> $GITHUB_OUTPUT
          else
            echo "response_message not found in message.json; mismatch -> will send email"
            echo "should_send=true" >> $GITHUB_OUTPUT
          fi

          # 导出原始（规范化后）消息以便邮件步骤使用
          echo "response_message=$response_message" >> $GITHUB_OUTPUT

      # ==========================================================================
      # 步骤7：有条件地发送邮件（仅当 should_send == 'true'）
      # 需要在仓库 Secrets 中配置：SMTP_SERVER, SMTP_PORT, SMTP_USERNAME, SMTP_PASSWORD, EMAIL_TO
      # 我使用 dawidd6/action-send-mail@v3 作为示例（可替换为其他邮件 action）
      - name: Check SMTP config
        id: smtp_check
        run: |
          echo "Checking SMTP configuration..."
          if [ -z "${{ secrets.SMTP_SERVER }}" ]; then
            echo "smtp_configured=false" >> $GITHUB_OUTPUT
            echo "SMTP_SERVER not set"
          else
            echo "smtp_configured=true" >> $GITHUB_OUTPUT
            echo "SMTP_SERVER is set"
          fi

      - name: Send email if message changed
        if: ${{ steps.decide.outputs.should_send == 'true' && steps.smtp_check.outputs.smtp_configured == 'true' }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: "[OCI Auto-Manager] Message changed in workflow run"
          to: ${{ secrets.EMAIL_TO }}
          from: ${{ secrets.SMTP_USERNAME }}
          body: |
            The workflow detected a matching message in the latest run.
            Run ID: ${{ github.run_id }}
            Run Number: ${{ github.run_number }}
            Returned message: ${{ steps.decide.outputs.response_message }}

      # 如果应该发送但未配置 SMTP_SERVER，写日志并跳过发送（由 smtp_check 步骤判断）
      - name: Log skipped email when SMTP not configured
        if: ${{ steps.decide.outputs.should_send == 'true' && steps.smtp_check.outputs.smtp_configured == 'false' }}
        run: |
          echo "should_send == true but SMTP_SERVER secret is not set; skipping email send."

